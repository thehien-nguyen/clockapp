<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ƒê·ªìng H·ªì Gia ƒê√¨nh (Mini-App)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Thi·∫øt l·∫≠p font Inter m·∫∑c ƒë·ªãnh v√† ƒë·∫£m b·∫£o cƒÉn gi·ªØa */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f4f8; /* N·ªÅn ngo√†i m√†u x√°m nh·∫°t */
        }
        
        /* ƒê·∫£m b·∫£o canvas c√≥ k√≠ch th∆∞·ªõc linh ho·∫°t v√† cƒÉn gi·ªØa */
        .app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            max-width: 440px;
            width: 95vw;
        }

        .clock-container {
            width: 100%;
            aspect-ratio: 1 / 1;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            border-radius: 9999px; /* Tr√≤n ho√†n to√†n */
            position: relative;
            background-color: white;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* V·ªã tr√≠ cho th√¥ng b√°o (Notification) */
        #notification-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 25px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            color: #333;
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            max-width: 80%;
            border: 3px solid #ff3333; /* Vi·ªÅn ƒë·ªè cho th√¥ng b√°o ƒë·∫∑c bi·ªát */
        }

        .show-notification {
            opacity: 1 !important;
        }

        .calendar-placeholder {
            font-size: 0.9rem;
            color: #ccc;
            margin-top: 10px;
        }

        /* Overlay b·∫Øt bu·ªôc click ƒë·ªÉ b·∫≠t √¢m thanh */
        #audio-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
        #audio-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
    <!-- B·∫Øt ƒë·∫ßu c√°c th·∫ª meta PWA/Mini-App -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#4A90E2">
    <!-- Link t·ªõi Manifest (M√¥ t·∫£ ·ª©ng d·ª•ng, c·∫ßn c√≥ manifest.json ri√™ng) -->
    <link rel="manifest" href="/family-clock-manifest.json">
    <!-- K·∫øt th√∫c c√°c th·∫ª meta PWA/Mini-App -->
</head>
<body>
    <div class="app-container">
        <!-- V√πng ch·ª©a ƒê·ªìng H·ªì -->
        <div class="clock-container">
            <canvas id="analogClock"></canvas>
            <div id="notification-box"></div>
        </div>
        
        <!-- Placeholder cho Google Calendar -->
        <div class="calendar-placeholder">
            (*) T√≠nh nƒÉng Google Calendar ƒë∆∞·ª£c m√¥ ph·ªèng. Tr√™n ·ª©ng d·ª•ng th·ª±c t·∫ø, s·ª± ki·ªán s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y.
        </div>
    </div>
    
    <!-- Audio Context cho TTS -->
    <audio id="ttsAudio" style="display: none;"></audio>

    <!-- Overlay B·∫Øt Bu·ªôc Nh·∫•n ƒë·ªÉ K√≠ch Ho·∫°t √Çm Thanh -->
    <div id="audio-overlay">
        <button id="enable-audio-btn" class="px-6 py-3 text-lg font-bold text-white bg-blue-600 rounded-lg shadow-xl hover:bg-blue-700 transition duration-300 transform hover:scale-105">
            Nh·∫•n ƒë·ªÉ B·∫≠t Gi·ªçng N√≥i (TTS)
        </button>
    </div>


    <script>
        // --- C·∫§U H√åNH API V√Ä √ÇM THANH ---
        const TTS_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=";
        const ROOSTER_VOICE = "Fenrir"; // Gi·ªçng m·∫°nh m·∫Ω, th√≠ch h·ª£p cho ti·∫øng g√† g√°y
        const FRIENDLY_VOICE = "Kore"; // Gi·ªçng th√¢n thi·ªán, th√≠ch h·ª£p cho l·ªùi ch√∫c

        // Tr·∫°ng th√°i c·ªù ƒë·ªÉ ƒë·∫£m b·∫£o b√°o th·ª©c ch·ªâ reo 1 l·∫ßn m·ªói gi·ªù
        const alarmFlags = {
            '06:00': false,
            '21:00': false,
            '22:00': false,
            'BIRTHDAY': false
        };

        // Danh s√°ch l·ªùi ch√∫c ng·∫´u nhi√™n
        const randomGreetings = [
            "Ch√∫c b·∫°n ng√†y m·ªõi t·ªët ƒë·∫πp!",
            "M·ªôt ng√†y m·ªõi th·∫≠t nƒÉng l∆∞·ª£ng nh√©!",
            "S·∫µn s√†ng chinh ph·ª•c m·ª•c ti√™u n√†o!",
            "B√¨nh minh r·ª±c r·ª° ƒëang ch·ªù b·∫°n!",
            "H√¥m nay s·∫Ω l√† m·ªôt ng√†y tuy·ªát v·ªùi!"
        ];
        
        // C·ªù ki·ªÉm tra tr·∫°ng th√°i √¢m thanh ƒë√£ ƒë∆∞·ª£c ng∆∞·ªùi d√πng b·∫≠t ch∆∞a
        let audioContextReady = false; 

        // --- C√ÅC H√ÄM X·ª¨ L√ù AUDIO (PCM to WAV) ---

        // Chuy·ªÉn Base64 sang ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Chuy·ªÉn PCM sang WAV
        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1; // Mono
            const bytesPerSample = 2; // 16-bit
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.byteLength;
            
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            let offset = 0;

            // RIFF chunk descriptor
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + dataSize, true); offset += 4; // ChunkSize
            writeString(view, offset, 'WAVE'); offset += 4;

            // fmt chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size
            view.setUint16(offset, 1, true); offset += 2; // AudioFormat (1=PCM)
            view.setUint16(offset, numChannels, true); offset += 2; // NumChannels
            view.setUint32(offset, sampleRate, true); offset += 4; // SampleRate
            view.setUint32(offset, byteRate, true); offset += 4; // ByteRate
            view.setUint16(offset, blockAlign, true); offset += 2; // BlockAlign
            view.setUint16(offset, bytesPerSample * 8, true); offset += 2; // BitsPerSample

            // data chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, dataSize, true); offset += 4;
            
            // Copy PCM data
            const pcmArray = new Int16Array(pcmData);
            for (let i = 0; i < pcmArray.length; i++) {
                view.setInt16(offset, pcmArray[i], true);
                offset += 2;
            }

            return new Blob([view], { type: 'audio/wav' });
        }
        
        function writeString(view, offset, str) {
            for (let i = 0; i < str.length; i++) {
                view.setUint8(offset + i, str.charCodeAt(i));
            }
        }

        // H√†m ph√°t TTS
        async function playTTS(text, voiceName, maxRetries = 3) {
            // KI·ªÇM TRA: Ch·ªâ ph√°t TTS n·∫øu ng∆∞·ªùi d√πng ƒë√£ b·∫≠t √¢m thanh
            if (!audioContextReady) {
                console.log("TTS blocked: User interaction required to enable audio.");
                return;
            }

            const audioEl = document.getElementById('ttsAudio');
            if (audioEl.paused === false) audioEl.pause(); // D·ª´ng n·∫øu ƒëang ph√°t

            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            let response;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    response = await fetch(TTS_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        break; // Th√†nh c√¥ng, tho√°t v√≤ng l·∫∑p
                    } else if (response.status === 429 && attempt < maxRetries - 1) {
                        // X·ª≠ l√Ω l·ªói Rate Limit v·ªõi Exponential Backoff
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        console.error('TTS API error:', response.status, await response.text());
                        return;
                    }
                } catch (error) {
                    console.error('Fetch error during TTS call:', error);
                    if (attempt < maxRetries - 1) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        return;
                    }
                }
            }
            
            if (!response || !response.ok) return;

            try {
                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    // L·∫•y sample rate t·ª´ mimeType (v√≠ d·ª•: audio/L16;rate=24000)
                    const rateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000; 

                    const pcmData = base64ToArrayBuffer(audioData);
                    const wavBlob = pcmToWav(pcmData, sampleRate);
                    
                    audioEl.src = URL.createObjectURL(wavBlob);
                    audioEl.play().catch(e => console.error("Error playing audio after enablement:", e));
                } else {
                    console.error("TTS response structure missing audio data or invalid mime type:", part);
                }
            } catch (error) {
                console.error("Error processing TTS response:", error);
            }
        }

        // --- C√ÅC THI·∫æT L·∫¨P CANVAS V√Ä TH·ªúI GIAN ---
        const canvas = document.getElementById('analogClock');
        const ctx = canvas.getContext('2d');
        const notificationBox = document.getElementById('notification-box');
        let radius;
        let animationFrameId;

        // H√†m ch√≠nh ƒë·ªÉ v·∫Ω ƒë·ªìng h·ªì
        function drawClock() {
            const now = new Date();
            const h = now.getHours();
            const m = now.getMinutes();
            const s = now.getSeconds();
            
            // L·∫•y k√≠ch th∆∞·ªõc th·ª±c t·∫ø c·ªßa canvas
            const size = Math.min(canvas.width, canvas.height);
            radius = size / 2;
            
            // Di chuy·ªÉn g·ªëc t·ªça ƒë·ªô v·ªÅ t√¢m canvas
            ctx.clearRect(0, 0, size, size); // X√≥a canvas
            ctx.save();
            ctx.translate(radius, radius); 

            // 1. V·∫Ω m·∫∑t ƒë·ªìng h·ªì (N·ªÅn xanh d∆∞∆°ng b√≥ng)
            drawFace(ctx, radius);

            // 2. V·∫Ω c√°c v·∫°ch s·ªë v√† kim c∆∞∆°ng
            drawNumbers(ctx, radius);
            
            // 3. V·∫Ω ng√†y th√°ng
            drawDate(ctx, radius, now);

            // 4. T√≠nh to√°n v√† v·∫Ω kim
            drawTime(ctx, radius, h, m, s);
            
            // 5. X·ª≠ l√Ω c√°c s·ª± ki·ªán b√°o th·ª©c, nh·∫Øc nh·ªü v√† sinh nh·∫≠t
            handleAlarms(h, m, s, now);

            // Tr·∫£ l·∫°i tr·∫°ng th√°i canvas ban ƒë·∫ßu
            ctx.restore(); 
        }

        // H√†m v·∫Ω n·ªÅn m·∫∑t ƒë·ªìng h·ªì v·ªõi hi·ªáu ·ª©ng b√≥ng (Glossy Blue)
        function drawFace(ctx, radius) {
            
            // V√≤ng tr√≤n ngo√†i (Shadow/Edge)
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#C6E2FF'; // Xanh nh·∫°t vi·ªÅn
            ctx.fill();
            
            // T·∫°o hi·ªáu ·ª©ng b√≥ng/s√°ng (Glossy Blue)
            const grad = ctx.createRadialGradient(0, 0, radius * 0.9, 0, 0, radius * 1.05);
            grad.addColorStop(0, '#4A90E2'); // M√†u xanh d∆∞∆°ng ƒë·∫≠m ·ªü t√¢m
            grad.addColorStop(0.7, '#6AAEE8'); // M√†u xanh d∆∞∆°ng trung b√¨nh
            grad.addColorStop(1, '#8AC0F0');  // M√†u xanh d∆∞∆°ng nh·∫°t ·ªü r√¨a
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.95, 0, 2 * Math.PI);
            ctx.fill();
            
            // Hi·ªáu ·ª©ng "Gloss" - V·ªát s√°ng b√≥ng
            const shine = ctx.createRadialGradient(0, -radius * 0.5, 0, 0, -radius * 0.5, radius * 0.8);
            shine.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
            shine.addColorStop(0.8, 'rgba(255, 255, 255, 0)');

            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.95, 0, 2 * Math.PI);
            ctx.fillStyle = shine;
            ctx.fill();
        }

        // SVG Kim C∆∞∆°ng v√† G√† Tr·ªëng
        // (L∆∞u √Ω: SVG kh√¥ng th·ªÉ v·∫Ω tr·ª±c ti·∫øp l√™n Canvas, ch·ªâ d√πng cho m·ª•c ƒë√≠ch tham kh·∫£o. 
        // Ch√∫ng ta ƒëang d√πng k·ªπ thu·∫≠t v·∫Ω h√¨nh h·ªçc v√† Emoji)
        const diamondSVG = `...`; 
        const roosterSVG = `...`; 

        // H√†m v·∫Ω s·ªë gi·ªù v√† Kim c∆∞∆°ng/G√† tr·ªëng
        function drawNumbers(ctx, radius) {
            let ang;
            let num;
            ctx.font = radius * 0.15 + "px Arial";
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            ctx.fillStyle = 'white'; 
            const hour = new Date().getHours();

            for (num = 1; num < 13; num++) {
                ang = num * Math.PI / 6;
                ctx.rotate(ang);
                ctx.translate(0, -radius * 0.85);
                ctx.rotate(-ang);

                if (num === 12) {
                    // 12 gi·ªù: Kim c∆∞∆°ng l·∫•p l√°nh
                    // L·∫•p l√°nh ƒë∆°n gi·∫£n b·∫±ng c√°ch thay ƒë·ªïi m√†u ho·∫∑c k√≠ch th∆∞·ªõc
                    const diamondSize = radius * 0.1;
                    ctx.fillStyle = '#E0FFFF'; // M√†u kim c∆∞∆°ng
                    ctx.shadowColor = (new Date().getMilliseconds() % 1000 < 500) ? 'yellow' : 'white';
                    ctx.shadowBlur = 10;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -diamondSize);
                    ctx.lineTo(diamondSize/2, 0);
                    ctx.lineTo(0, diamondSize);
                    ctx.lineTo(-diamondSize/2, 0);
                    ctx.closePath();
                    ctx.fill();

                    ctx.shadowBlur = 0; // T·∫Øt b√≥ng
                    ctx.fillStyle = 'white';

                } else if (num === 5 && hour === 5 && new Date().getMinutes() < 30) {
                    // 5 gi·ªù s√°ng: Hi·ªÉn th·ªã g√† tr·ªëng (D√πng Text l√†m placeholder cho SVG)
                    ctx.font = radius * 0.18 + "px Arial";
                    ctx.fillStyle = '#FFC300';
                    ctx.fillText("üêî", 0, 0); // Emoji G√† tr·ªëng
                    ctx.font = radius * 0.15 + "px Arial"; // Tr·∫£ v·ªÅ font c≈©
                    ctx.fillStyle = 'white';
                } else {
                    ctx.fillText(num.toString(), 0, 0);
                }
                
                ctx.rotate(ang);
                ctx.translate(0, radius * 0.85);
                ctx.rotate(-ang);
            }
        }
        
        // H√†m v·∫Ω Ng√†y th√°ng
        function drawDate(ctx, radius, now) {
            const days = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
            const months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
            
            const dayOfWeek = days[now.getDay()];
            const month = months[now.getMonth()];
            const date = now.getDate();
            
            const dateStr = `${dayOfWeek}, ${month} ${date}`;
            
            ctx.font = radius * 0.08 + "px Arial";
            ctx.fillStyle = '#E0FFFF'; // M√†u tr·∫Øng xanh
            ctx.textAlign = "center";
            ctx.fillText(dateStr, 0, radius * 0.45); // V·ªã tr√≠ d∆∞·ªõi t√¢m
        }


        // H√†m v·∫Ω kim ƒë·ªìng h·ªì
        function drawTime(ctx, radius, h, m, s) {
            
            // G√≥c kim gi·ªù: 30 ƒë·ªô/gi·ªù + 0.5 ƒë·ªô/ph√∫t + 0.0083 ƒë·ªô/gi√¢y
            let hourAngle = (h % 12 + m / 60 + s / 3600) * Math.PI / 6;
            drawHand(ctx, hourAngle, radius * 0.5, radius * 0.07, 'black'); // Kim gi·ªù m√†u ƒëen

            // G√≥c kim ph√∫t: 6 ƒë·ªô/ph√∫t + 0.1 ƒë·ªô/gi√¢y
            let minuteAngle = (m + s / 60) * Math.PI / 30;
            drawHand(ctx, minuteAngle, radius * 0.75, radius * 0.05, 'black'); // Kim ph√∫t m√†u ƒëen

            // G√≥c kim gi√¢y: 6 ƒë·ªô/gi√¢y
            let secondAngle = s * Math.PI / 30;
            drawHand(ctx, secondAngle, radius * 0.85, radius * 0.02, '#FFD700'); // Kim gi√¢y m√†u v√†ng (#FFD700 - Gold)

            // V·∫Ω ch·ªët t√¢m
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.05, 0, 2 * Math.PI);
            ctx.fillStyle = '#333';
            ctx.fill();
        }

        // H√†m v·∫Ω kim chung
        function drawHand(ctx, pos, length, width, color) {
            ctx.beginPath();
            ctx.lineWidth = width;
            ctx.lineCap = "round";
            ctx.strokeStyle = color;
            
            // Xoay canvas theo v·ªã tr√≠ (pos)
            ctx.rotate(pos - Math.PI / 2); 
            ctx.moveTo(0, 0);
            ctx.lineTo(length, 0);
            ctx.stroke();
            
            // Tr·∫£ l·∫°i g√≥c quay ban ƒë·∫ßu
            ctx.rotate(-(pos - Math.PI / 2));
        }

        // H√†m hi·ªÉn th·ªã th√¥ng b√°o
        function showNotification(message, duration = 5000) {
            notificationBox.textContent = message;
            notificationBox.classList.add('show-notification');
            setTimeout(() => {
                notificationBox.classList.remove('show-notification');
            }, duration);
        }

        // H√†m x·ª≠ l√Ω c√°c s·ª± ki·ªán b√°o th·ª©c v√† nh·∫Øc nh·ªü
        function handleAlarms(h, m, s, now) {
            const timeKey = `${h < 10 ? '0' + h : h}:${m < 10 ? '0' + m : m}`;
            
            // 1. Ki·ªÉm tra Sinh Nh·∫≠t (30/09)
            // L∆∞u √Ω: JavaScript month l√† 0-indexed, n√™n th√°ng 10 l√† 9.
            const isBirthday = now.getMonth() === 9 && now.getDate() === 30; 
            
            // --- Hi·ªÉn th·ªã d√≤ng ch·ªØ Ch√∫c m·ª´ng Sinh Nh·∫≠t (6:00 ƒë·∫øn 21:59) ---
            // Y√™u c·∫ßu: Hi·ªÉn th·ªã t·ª´ 6:00 s√°ng ƒë·∫øn 22:00 (ƒëi ng·ªß)
            if (isBirthday && h >= 6 && h < 22) { 
                // Th√¥ng b√°o tr√™n m·∫∑t ƒë·ªìng h·ªì
                ctx.font = radius * 0.1 + "px Arial";
                ctx.fillStyle = '#FF3333';
                ctx.textAlign = "center";
                // D√≤ng ch·ªØ ch√∫c m·ª´ng sinh nh·∫≠t ƒë∆∞·ª£c hi·ªÉn th·ªã trong kho·∫£ng th·ªùi gian m·ªõi
                ctx.fillText("‚ù§Ô∏è happy birthday my love and my son ‚ù§Ô∏è", 0, radius * 0.65);
            } 
            
            // --- K√≠ch ho·∫°t TTS Sinh Nh·∫≠t (Ch·ªâ 1 l·∫ßn l√∫c 6:00:00) ---
            if (isBirthday && !alarmFlags.BIRTHDAY && h === 6 && m === 0 && s === 0) {
                // Ph√°t TTS
                const birthdayTTS = "Ch√∫c m·ª´ng sinh nh·∫≠t hai m·∫π con G·∫•u!";
                playTTS(birthdayTTS, FRIENDLY_VOICE);
                alarmFlags.BIRTHDAY = true; // ƒê·∫£m b·∫£o ch·ªâ ph√°t 1 l·∫ßn trong ng√†y
            } else if (!isBirthday) {
                // ƒê·∫∑t l·∫°i c·ªù cho nƒÉm sau
                alarmFlags.BIRTHDAY = false;
            }


            // 2. Ki·ªÉm tra B√°o Th·ª©c kh√°c (Ch·ªâ k√≠ch ho·∫°t khi m=00 v√† s=00)
            if (m === 0 && s === 0) {
                // Reset c·ªù cho t·∫•t c·∫£ c√°c gi·ªù kh√°c
                Object.keys(alarmFlags).forEach(key => {
                    if (key !== timeKey && key !== 'BIRTHDAY') {
                        alarmFlags[key] = false;
                    }
                });

                if (timeKey === '06:00' && !alarmFlags['06:00'] && !isBirthday) { // Ch·ªâ g√°y khi KH√îNG ph·∫£i sinh nh·∫≠t
                    // 6:00 s√°ng: G√† g√°y v√† l·ªùi ch√∫c
                    showNotification(randomGreetings[Math.floor(Math.random() * randomGreetings.length)], 8000);
                    playTTS("√í √≥ o o o", ROOSTER_VOICE);
                    alarmFlags['06:00'] = true;
                } 
                else if (timeKey === '21:00' && !alarmFlags['21:00']) {
                    // 21:00: Nh·∫Øc nh·ªü ƒëi ng·ªß
                    const reminder = "B·∫°n ∆°i s·∫Øp ƒë·∫øn gi·ªù ƒëi ng·ªß r·ªìi ƒë·∫•y, h√£y mau ho√†n th√†nh c√¥ng vi·ªác v√† chu·∫©n b·ªã ƒëi ng·ªß th√¥i.";
                    showNotification(reminder, 10000);
                    playTTS(reminder, FRIENDLY_VOICE);
                    alarmFlags['21:00'] = true;
                }
                else if (timeKey === '22:00' && !alarmFlags['22:00']) {
                    // 22:00: Ch√∫c ng·ªß ngon
                    const goodnight = "Ch√∫c ng·ªß ngon nh√©.";
                    showNotification(goodnight, 5000);
                    playTTS(goodnight, FRIENDLY_VOICE);
                    alarmFlags['22:00'] = true;
                }
            }

            // 3. Hi·ªÉn th·ªã G√† tr·ªëng (5:00 - 5:30)
            if (h === 5 && m >= 0 && m < 30) {
                // Kh√¥ng c·∫ßn v·∫Ω l·∫°i g√† tr·ªëng ·ªü ƒë√¢y v√¨ n√≥ ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong drawNumbers
            }
        }
        
        // --- V√íNG L·∫∂P V√Ä KH·ªûI T·∫†O ---

        // H√†m kh·ªüi ƒë·ªông v√≤ng l·∫∑p animation
        function startClock() {
             if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            const update = () => {
                drawClock();
                // S·ª≠ d·ª•ng requestAnimationFrame ƒë·ªÉ ƒë·ªìng b·ªô v·ªõi m√†n h√¨nh, nh∆∞ng ch·ªâ c·∫ßn c·∫≠p nh·∫≠t m·ªói gi√¢y
                setTimeout(() => {
                    animationFrameId = requestAnimationFrame(update);
                }, 1000 - (new Date().getMilliseconds())); 
            };
            animationFrameId = requestAnimationFrame(update);
        }


        // ƒê·∫∑t l·∫°i k√≠ch th∆∞·ªõc canvas khi t·∫£i trang ho·∫∑c thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï
        function resizeCanvas() {
            const container = document.querySelector('.clock-container');
            const containerSize = container.offsetWidth;
            
            // Thi·∫øt l·∫≠p c·∫£ width v√† height c·ªßa canvas
            canvas.width = containerSize;
            canvas.height = containerSize;
            
            // V·∫Ω l·∫°i ƒë·ªìng h·ªì ngay sau khi thay ƒë·ªïi k√≠ch th∆∞·ªõc
            // G·ªçi startClock() ƒë·ªÉ ƒë·∫£m b·∫£o v√≤ng l·∫∑p b·∫Øt ƒë·∫ßu
            startClock();
        }

        // H√†m x·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n n√∫t B·∫≠t √¢m thanh
        function enableAudio() {
            const overlay = document.getElementById('audio-overlay');
            
            // 1. ƒê√°nh d·∫•u √¢m thanh ƒë√£ s·∫µn s√†ng
            audioContextReady = true; 
            
            // 2. ·∫®n m√†n h√¨nh ch·ªù
            overlay.classList.add('hidden');

            // 3. K√≠ch ho·∫°t audio context (c·∫ßn thi·∫øt cho m·ªôt s·ªë tr√¨nh duy·ªát iOS/Safari)
            const audioEl = document.getElementById('ttsAudio');
            // Th·ª≠ ph√°t 1 ƒëo·∫°n audio im l·∫∑ng ƒë·ªÉ "m·ªü kh√≥a"
            audioEl.volume = 0;
            audioEl.play().then(() => {
                audioEl.pause();
                audioEl.volume = 1;
            }).catch(e => {
                // N·∫øu th·∫•t b·∫°i (v√≠ d·ª•: m√°y t√≠nh ƒë·ªÉ b√†n), v·∫´n ti·∫øp t·ª•c v√¨ c·ªù ƒë√£ b·∫≠t
                console.warn("Silent audio context unlocking failed:", e);
            });
            
            // N·∫øu b·∫°n mu·ªën th·ª≠ nghi·ªám ngay, c√≥ th·ªÉ g·ªçi playTTS test ·ªü ƒë√¢y
            // playTTS("Gi·ªçng n√≥i ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t th√†nh c√¥ng.", FRIENDLY_VOICE);
        }


        // Kh·ªüi t·∫°o
        window.onload = function() {
            resizeCanvas(); 
            window.addEventListener('resize', resizeCanvas); 
            
            // G√°n s·ª± ki·ªán click cho n√∫t b·∫≠t √¢m thanh
            document.getElementById('enable-audio-btn').addEventListener('click', enableAudio);
        }
    </script>

</body>
</html>
